package kouplettest

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"

	apiv1alpha1 "github.com/jgwest/kouplet-operator/api/v1alpha1"

	"github.com/jgwest/kouplet-operator/controllers/shared"
	kubeerrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/types"
)

type persistenceEntryType uint8

// PersistenceDebug ...
const PersistenceDebug = true

const (
	addTestStartTime = persistenceEntryType(iota)
	removeTestStartTime
	updateTestCollectionShallow
	updateTestEntryShallow
	updateTestEntryResult
	updateTestEntryTestEntry
	deleteTestCollection
)

func p9e_debugf(format string, a ...interface{}) {
	if PersistenceDebug {
		logStr := fmt.Sprintf("[p9e-debug]  "+format+"\n", a)
		shared.LogDebug(logStr)
	}
}

func NewPersistenceContext(path string) *PersistenceContext {
	perStore, err := shared.NewFilePersistence(path)

	if err != nil {
		shared.LogErrorMsg(err, "Unable to create file persistence context")
		return nil
	}

	var persistenceStore shared.PersistenceStore = perStore

	return &PersistenceContext{
		persistenceStore: &persistenceStore,

		// A list of changes made to the database
		entryMap: make(map[string]*PersistenceEntry),
	}
}

// PersistenceContext ...
type PersistenceContext struct {
	// key: generated by PersistenceEntry.updateKey()
	entryMap         map[string]*PersistenceEntry
	persistenceStore *shared.PersistenceStore
}

func (pc *PersistenceContext) load(ctx KTContext) (*KoupletDB, error) {

	db := &KoupletDB{
		persistenceContext: *pc,
		collections:        make(map[string]*TestCollection),
		testStartTimes:     []time.Time{},
	}

	ps := (*pc.persistenceStore)

	entities, err := ps.ListKeysByPrefix("test-collection-entity-")
	if err != nil {
		shared.LogSevereMsg(err, "Unable to load test collection entity values")
		return nil, err
	}

	// Load all the test collections into the db
	for _, tcEntityKey := range entities {

		result, err := ps.ReadValues([]string{tcEntityKey})
		if err != nil {
			shared.LogErrorMsg(err, "Unable to find value "+tcEntityKey)
			continue
		}

		val := result[tcEntityKey]
		if val == nil {
			shared.LogError(errors.New("No value for key-value " + tcEntityKey))
			continue
		}

		jstc := JSONShallowTestCollection{}
		err = unmarshalFromJSON(*val, &jstc)
		if err != nil {
			shared.LogErrorMsg(err, "Unable to unmarshal "+*val)
			continue
		}

		// Fetch the KoupletTest instance and populate the test collection using that
		tc := (*TestCollection)(nil)
		{
			instance := &apiv1alpha1.KoupletTest{}
			err := (*ctx.Client).Get(context.TODO(), types.NamespacedName{
				Namespace: jstc.KubeObjNamespace,
				Name:      jstc.KubeObjName,
			}, instance)

			if err != nil {
				if kubeerrors.IsNotFound(err) {
					shared.LogDebug("Debug: Unable to locate KoupletTest Instance " + jstc.KubeObjNamespace + "/" + jstc.KubeObjName + ", it was likely deleted.")
				} else {
					shared.LogSevere(err)
				}
				continue
			}

			if string(instance.UID) != jstc.KubeObjUUID {
				shared.LogInfo("Debug: TestCollection UUID did not match Kube Object UID: " + string(instance.UID) + " " + jstc.KubeObjUUID)
				continue
			}

			tc = newTestCollection(*instance)

			tc.status, err = stringToTestCollectionStatus(jstc.Status)
			if err != nil {
				shared.LogSevereMsg(err, "Invalid status value")
				continue
			}

			tc.dateSubmitted = jstc.DateSubmitted
			tc.startTime = jstc.StartTime
			tc.endTime = jstc.EndTime
			tc.nextTestEntryID = jstc.NextTestEntryID

			tc.bucket, err = stringToTestCollectionBucket(jstc.ParentBucket)
			if err != nil {
				shared.LogSevereMsg(err, "Invalid test collection bucket value")
				continue
			}

			db.addToBucketForPersistence(tc)
		}
	} // end for, load test collections

	for testCollectionUUID, tc := range db.collections {

		// Load shallow test entries for the collection
		{
			shallowKeys, err := ps.ListKeysByPrefix("test-collection-" + testCollectionUUID + "-test-entry-shallow-")
			if err != nil {
				shared.LogSevereMsg(err, "Unable to retrieve shallow test entries values")
				return nil, err
			}
			shallowEntryValues, err := ps.ReadValues(shallowKeys)
			if err != nil {
				shared.LogSevereMsg(err, "Unable to read key values")
				return nil, err
			}
			for key, entity := range shallowEntryValues {

				if entity == nil {
					shared.LogError(errors.New("Unable to locate shallow test entry with id " + key))
					continue
				}

				jtes := JSONTestEntryShallow{}

				err := unmarshalFromJSON(*entity, &jtes)
				if err != nil {
					shared.LogErrorMsg(err, "Unable to unmarshal JSON: "+*entity)
					continue
				}

				newTestEntry := &TestEntry{
					id:              jtes.ID,
					retryFromID:     jtes.RetryFromID,
					result:          nil,
					testEntry:       apiv1alpha1.KoupletTestEntry{},
					processed:       jtes.Processed,
					clusterResource: jtes.ClusterResource,
				}

				status, err := stringToTestEntryStatus(jtes.Status)
				if err != nil {
					shared.LogSevere(err)
					continue
				}
				newTestEntry.status = status

				bucket, err := stringToTestEntryBucket(jtes.ParentBucket)
				if err != nil {
					shared.LogSevere(err)
					continue
				}
				newTestEntry.bucket = bucket
				tc.addToTestEntriesForPersistence(newTestEntry)
			} // end shallow test entry for
		}

		// Read test entry test entries
		{
			testEntryTestEntryKeys, err := ps.ListKeysByPrefix("test-collection-" + testCollectionUUID + "-test-entry-test-entry-")
			if err != nil {
				shared.LogSevereMsg(err, "Unable to list TE test entries")
				return nil, err
			}
			teTestEntryValues, err := ps.ReadValues(testEntryTestEntryKeys)
			if err != nil {
				shared.LogSevereMsg(err, "Unable to read TE test entries")
				return nil, err
			}
			for key, teTEValue := range teTestEntryValues {

				if teTEValue == nil {
					shared.LogError(errors.New("Unable to locate TE test entry with id " + key))
					continue
				}

				// Extract the test ID from the key
				testEntryID := -1
				{
					lastHyphenIndex := strings.LastIndex(key, "-")
					if lastHyphenIndex == -1 {
						shared.LogSevere(errors.New("Unable to extract test ID from test entry's test entry key"))
						continue
					}

					testEntryID, err = strconv.Atoi(key[lastHyphenIndex+1:])
					if err != nil {
						shared.LogSevere(errors.New("Unable to parse test ID from test entry's test entry key"))
						continue
					}
				}

				jtes := apiv1alpha1.KoupletTestEntry{}

				err := unmarshalFromJSON(*teTEValue, &jtes)
				if err != nil {
					shared.LogErrorMsg(err, "Unable to parse TE test entry JSON value: "+*teTEValue)
					continue
				}

				testEntry := tc.GetTestEntry(testEntryID)
				if testEntry == nil {
					shared.LogError(fmt.Errorf("Unable to locate test entry %d in test collection: %s", testEntryID, tc.uuid))
					continue
				}
				testEntry.testEntry = jtes

			}
		}

		// Read test entry results
		{
			testEntryResultKeys, err := ps.ListKeysByPrefix("test-collection-" + testCollectionUUID + "-test-entry-result-")
			if err != nil {
				shared.LogSevereMsg(err, "Unable to list test entry results")
				return nil, err
			}
			testEntryResultValues, err := ps.ReadValues(testEntryResultKeys)
			if err != nil {
				shared.LogSevereMsg(err, "Unable to read test entry results")
				return nil, err
			}
			for key, testEntryResultValue := range testEntryResultValues {

				if testEntryResultValue == nil {
					shared.LogError(errors.New("Unable to locate test entry result with id " + key))
					continue
				}

				teResult := apiv1alpha1.KoupletTestJobResultEntry{}
				err := unmarshalFromJSON(*testEntryResultValue, &teResult)
				if err != nil {
					shared.LogErrorMsg(err, "Unable to unmarshal JSON: "+*testEntryResultValue)
					continue
				}

				testEntry := tc.GetTestEntry(teResult.ID)
				if testEntry == nil {
					shared.LogError(fmt.Errorf("Unable to locate test entry %d in test collection %s", teResult.ID, tc.uuid))
					continue
				}
				testEntry.result = &teResult
			}
		}

		// Now that we have loaded all the test entries, sort them by ID
		sort.SliceStable(tc.queuedTests, func(i, j int) bool {
			return tc.queuedTests[i].id < tc.queuedTests[j].id
		})
		sort.SliceStable(tc.runningTests, func(i, j int) bool {
			return tc.runningTests[i].id < tc.runningTests[j].id
		})
		sort.SliceStable(tc.completedTests, func(i, j int) bool {
			return tc.completedTests[i].id < tc.completedTests[j].id
		})
		sort.SliceStable(tc.testsForRetry, func(i, j int) bool {
			return tc.testsForRetry[i].id < tc.testsForRetry[j].id
		})

	} // end for, iterate over test collections in db

	testStartTimeKeys, err := ps.ListKeysByPrefix("test-start-time-")
	if err == nil {

		for _, testStartTimeKey := range testStartTimeKeys {

			lastHyphenIndex := strings.LastIndex(testStartTimeKey, "-")
			if lastHyphenIndex == -1 {
				shared.LogSevere(errors.New("Unable to extract key from test start time: " + testStartTimeKey))
				continue
			}

			startTimeValue, err := strconv.ParseInt(testStartTimeKey[lastHyphenIndex+1:], 10, 64)
			if err != nil {
				shared.LogSevere(errors.New("Unable to parse key from test start time: " + testStartTimeKey))
				continue
			}

			db.addTestStartTimeForPersistence(startTimeValue)
		}
	} else {
		shared.LogSevereMsg(err, "Unable to list test start times")
		return nil, err
	}

	// Sort the collections by date submitted, and test start times
	sort.SliceStable(db.waitingCollections, func(i, j int) bool {
		return *(db.waitingCollections[i].dateSubmitted) < *(db.waitingCollections[j].dateSubmitted)
	})
	sort.SliceStable(db.runningCollections, func(i, j int) bool {
		return *(db.runningCollections[i].dateSubmitted) < *(db.runningCollections[j].dateSubmitted)
	})
	sort.SliceStable(db.completedCollections, func(i, j int) bool {
		return *(db.completedCollections[i].dateSubmitted) < *(db.completedCollections[j].dateSubmitted)
	})
	sort.SliceStable(db.testStartTimes, func(i, j int) bool {
		return db.testStartTimes[i].UnixNano() < db.testStartTimes[j].UnixNano()
	})

	shared.LogInfo(fmt.Sprintf("Database loaded - testCollections %d, start times %d", len(db.collections), len(db.testStartTimes)))

	return db, nil

}

func (pc *PersistenceContext) resolve(db *KoupletDB) {

	// Generate a list of collections to be deleted, by UUID
	testCollectionsToDelete := make(map[string] /* tc uuid -> unused value*/ bool)
	for _, entry := range pc.entryMap {

		if entry.entryType == deleteTestCollection {
			testCollectionsToDelete[*entry.testCollectionUUID] = true
		}
	}

	// Filter out any entries that match one of the collections to be deleted
	entriesToProcess := []*PersistenceEntry{}
	for _, entry := range pc.entryMap {

		delete := false

		if entry.testCollectionUUID != nil {

			if _, exists := testCollectionsToDelete[*entry.testCollectionUUID]; exists {
				delete = true
			}
		}

		if !delete {
			entriesToProcess = append(entriesToProcess, entry)
		}

	}

	// Clear the entryMap
	pc.entryMap = make(map[string]*PersistenceEntry)

	for tcUUID := range testCollectionsToDelete {

		// Clear the parent values
		matchingValues, err := (*pc.persistenceStore).ListKeysByPrefix("test-collection-entity-" + tcUUID)
		if err != nil {
			shared.LogErrorMsg(err, "Unable to find test collection objects")
			continue
		}
		(*pc.persistenceStore).DeleteByKey(matchingValues)

		// Clear the child values
		matchingValues, err = (*pc.persistenceStore).ListKeysByPrefix("test-collection-" + tcUUID)
		if err != nil {
			shared.LogErrorMsg(err, "Unable to find test collection objects")
			continue
		}
		(*pc.persistenceStore).DeleteByKey(matchingValues)

	}

	// kvResults is a bulk list of k-v pairs to write to the DB at the end of the function
	kvResult := make(map[string]string)

	for _, entry := range entriesToProcess {

		p9e_debugf("Processing entry, key: %v", entry.key)

		// If the testCollectionUUID is specified, ensure it is valid, then set it
		testCollection := (*TestCollection)(nil)
		if entry.testCollectionUUID != nil {
			val, exists := db.collections[*(entry.testCollectionUUID)]

			if exists {
				testCollection = val
			} else {
				shared.LogError(errors.New("For " + entry.key + ", unable to locate test collection in persistence entry: " + *entry.testCollectionUUID))
				continue
			}
		}

		// If the testEntryID is specified, ensure it value, then set it
		testEntry := (*TestEntry)(nil)
		if entry.testEntryID != nil && testCollection != nil {
			val, exists := testCollection.testEntries[*entry.testEntryID]
			if exists {
				testEntry = val
			} else {
				shared.LogError(fmt.Errorf("For %s, unable to locate test entry in persistence entry: %s %d", entry.key, *entry.testCollectionUUID, *entry.testEntryID))
				continue
			}
		}

		if entry.entryType == addTestStartTime {
			key := fmt.Sprintf("test-start-time-%d", ConvertToUnixEpochMsecs(entry.startTime))
			kvResult[key] = ""
		}

		if entry.entryType == removeTestStartTime {
			key := fmt.Sprintf("test-start-time-%d", ConvertToUnixEpochMsecs(entry.startTime))
			(*pc.persistenceStore).DeleteByKey([]string{key})
		}

		if entry.entryType == updateTestCollectionShallow && testCollection != nil {

			key := "test-collection-entity-" + *entry.testCollectionUUID

			value, err := marshalToJSON(generateJSONTestCollection(testCollection))

			if err == nil {
				kvResult[key] = value
			} else {
				shared.LogErrorMsg(err, "Unable to marshal, key: "+key)
				continue
			}

		}

		if entry.entryType == updateTestEntryShallow && testCollection != nil && testEntry != nil {

			key := fmt.Sprintf("test-collection-%s-test-entry-shallow-%d", *entry.testCollectionUUID, testEntry.id)

			value, err := marshalToJSON(generateJSONTestEntryShallow(testEntry))

			if err == nil {
				kvResult[key] = value
			} else {
				shared.LogErrorMsg(err, "Unable to marshal, key: "+key)
				continue
			}

		}

		if entry.entryType == updateTestEntryResult && testCollection != nil && testEntry != nil && testEntry.result != nil {

			key := fmt.Sprintf("test-collection-%s-test-entry-result-%d", *entry.testCollectionUUID, testEntry.id)

			value, err := marshalToJSON(testEntry.result)
			if err == nil {
				kvResult[key] = value
			} else {
				shared.LogErrorMsg(err, "Unable to marshal, key: "+key)
				continue
			}

		}

		if entry.entryType == updateTestEntryTestEntry && testCollection != nil && testEntry != nil {
			key := fmt.Sprintf("test-collection-%s-test-entry-test-entry-%d", *entry.testCollectionUUID, testEntry.id)

			value, err := marshalToJSON(testEntry.testEntry)
			if err == nil {
				kvResult[key] = value
			} else {
				shared.LogErrorMsg(err, "Unable to marshal, key: "+key)
				continue
			}

		}
	} // end for

	if len(kvResult) > 0 {
		err := (*pc.persistenceStore).WriteValues(kvResult)
		if err != nil {
			shared.LogError(errors.New("Unable to write values"))
		}
	}
}

func (pc *PersistenceContext) deleteTestCollection(collection *TestCollection) {

	entry := &PersistenceEntry{
		entryType:          deleteTestCollection,
		testCollectionUUID: &collection.uuid,
	}

	pc.putEntry(entry)

}

// Marshall the testEntry field of 'testEntry' which contains the apiv1alpha1.KoupletTestEntry (tests, labels, envs)
func (pc *PersistenceContext) updateTestEntryTestEntry(testEntry *TestEntry, collection *TestCollection) {

	entry := &PersistenceEntry{
		entryType:          updateTestEntryTestEntry,
		testCollectionUUID: &collection.uuid,
		testEntryID:        &testEntry.id,
	}

	pc.putEntry(entry)

}

// Persist the apiv1alpha1.KoupletTestJobResultEntry result from the test entry
func (pc *PersistenceContext) updateTestEntryResult(testEntry *TestEntry, collection *TestCollection) {

	entry := &PersistenceEntry{
		entryType:          updateTestEntryResult,
		testCollectionUUID: &collection.uuid,
		testEntryID:        &testEntry.id,
	}

	pc.putEntry(entry)

}

// Generate a JSONShallowTestCollection from the collection, and persist that
func (pc *PersistenceContext) updateTestCollectionShallow(collection *TestCollection) {

	entry := &PersistenceEntry{
		entryType:          updateTestCollectionShallow,
		testCollectionUUID: &(collection.uuid),
	}

	pc.putEntry(entry)
}

// Generate a JSONTestEntryShallow from the test entry, and persist that
func (pc *PersistenceContext) updateTestEntryShallow(testEntry *TestEntry, collection *TestCollection) {

	entry := &PersistenceEntry{
		entryType:          updateTestEntryShallow,
		testCollectionUUID: &collection.uuid,
		testEntryID:        &testEntry.id,
	}

	pc.putEntry(entry)
}

func (pc *PersistenceContext) addTestStartTime(time time.Time) {

	entry := &PersistenceEntry{
		entryType: addTestStartTime,
		startTime: &time,
	}

	pc.putEntry(entry)
}

func (pc *PersistenceContext) removeTestStartTime(time time.Time) {

	entry := &PersistenceEntry{
		entryType: removeTestStartTime,
		startTime: &time,
	}

	pc.putEntry(entry)
}

func (pc *PersistenceContext) putEntry(entry *PersistenceEntry) {
	entry.updateKey()
	entry.timestamp = time.Now()

	pc.entryMap[entry.key] = entry
}

// taskRemoveOldDatabaseKeys deletes database keys if the UUID in the key does not match a test collection UUID in the database.
// This function works for all database entity types, including test-cllection-entity
func taskRemoveOldDatabaseKeys(db *KoupletDB, ctx KTContext) error {

	pc := db.persistenceContext

	collectionUUIDs := []string{}
	for _, v := range db.collections {
		collectionUUIDs = append(collectionUUIDs, v.uuid)
	}

	keysToDelete := []string{}

	// Note this does include 'test-collection-entity-*'
	allDBKeys, err := (*pc.persistenceStore).ListKeysByPrefix("test-collection-")
	if err != nil {
		shared.LogErrorMsg(err, "Unable to acquire test values")
		return err
	}

	for _, key := range allDBKeys {

		dbKeyMatchesExistingCollection := false

		// Go through all the existing collection UUIDs and try to match against 'key'
		for _, collUUID := range collectionUUIDs {
			if strings.Index(key, collUUID) != -1 {
				dbKeyMatchesExistingCollection = true
				break
			}
		}

		// If the key did not contain at least one matching UUID, delete it
		if !dbKeyMatchesExistingCollection {
			keysToDelete = append(keysToDelete, key)
			shared.LogDebug("Old DB key marked for deletion " + key)
		}
	}

	err = (*pc.persistenceStore).DeleteByKey(keysToDelete)
	if err != nil {
		shared.LogErrorMsg(err, "Unable to delete old keys")
		return err
	}

	return nil
}

// PersistenceEntry ...
type PersistenceEntry struct {
	key       string
	entryType persistenceEntryType
	timestamp time.Time

	startTime          *time.Time
	testCollectionUUID *string
	testEntryID        *int
}

func (e *PersistenceEntry) updateKey() {

	var key string

	if e.entryType != addTestStartTime && e.entryType != removeTestStartTime {

		key = fmt.Sprintf("%d-", e.entryType)

		if e.testCollectionUUID != nil {
			key += *e.testCollectionUUID
		} else {
			key += "nil-"
		}

		if e.testEntryID != nil {
			key += strconv.Itoa(*e.testEntryID)
		} else {
			key += "nil"
		}
	} else {

		// Add/remove test start time works differently from other update types; just generate a non-duplicate key
		if e.startTime != nil {
			key = fmt.Sprintf("%d-%d", e.entryType, e.startTime.UnixNano())
		}
	}

	if len(strings.TrimSpace(key)) == 0 {
		shared.LogSevere(fmt.Errorf("Persistence entry key was updated to empty string, entryType: %d ", e.entryType))
	}

	e.key = key
}

// ConvertToUnixEpochMsecs ...
func ConvertToUnixEpochMsecs(time *time.Time) int64 {
	return time.UnixNano() / 1000000

}

func unmarshalFromJSON(str string, obj interface{}) error {
	return json.Unmarshal([]byte(str), &obj)
}

func marshalToJSON(obj interface{}) (string, error) {
	result, err := json.Marshal(obj)

	if err != nil {
		return "", nil
	}

	return string(result), nil

}

func generateJSONTestCollection(tc *TestCollection) *JSONShallowTestCollection {

	return &JSONShallowTestCollection{
		ParentBucket:     testCollectionBucketToString(tc.bucket),
		KubeObjNamespace: tc.kubeObj.Namespace,
		KubeObjName:      tc.kubeObj.Name,
		KubeObjUUID:      string(tc.kubeObj.UID),
		NextTestEntryID:  tc.nextTestEntryID,
		UUID:             tc.uuid,
		Status:           testCollectionStatusToString(tc.status),
		DateSubmitted:    tc.dateSubmitted,
		StartTime:        tc.startTime,
		EndTime:          tc.endTime,
	}
}

// JSONShallowTestCollection ...
type JSONShallowTestCollection struct {
	ParentBucket string `json:"parentBucket"`

	KubeObjNamespace string `json:"kubeObjNamespace"`
	KubeObjName      string `json:"kubeObjName"`
	KubeObjUUID      string `json:"kubeObjUUID"`

	NextTestEntryID int    `json:"nextTestEntryID"`
	UUID            string `json:"uuid"`

	Status string `json:"testCollectionStatus"`

	DateSubmitted *int64 `json:"dateSubmitted,omitempty"`

	StartTime *int64 `json:"startTime,omitempty"`
	EndTime   *int64 `json:"endTime,omitempty"`
}

func generateJSONTestEntryShallow(testEntry *TestEntry) *JSONTestEntryShallow {

	return &JSONTestEntryShallow{
		ParentBucket:    testEntryBucketToString(testEntry.bucket),
		ID:              testEntry.id,
		RetryFromID:     testEntry.retryFromID,
		Status:          testEntryStatusToString(testEntry.status),
		ClusterResource: testEntry.clusterResource,
		Processed:       testEntry.processed,
	}
}

// JSONTestEntryShallow ...
type JSONTestEntryShallow struct {
	ParentBucket string `json:"parentBucket"`

	ID          int  `json:"id"`
	RetryFromID *int `json:"retryFromID,omitempty"`

	Status string `json:"status"`

	ClusterResource *apiv1alpha1.KoupletTestJobResultClusterResource `json:"clusterResource,omitempty"`
	Processed       bool                                             `json:"processed"`
}
